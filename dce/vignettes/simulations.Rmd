---
title: "Simulations: Differential causal effects for pathway enrichment \n
Simulations of differential causal effects between two groups."
author: "Kim Jablonski, Martin Pirkl"
date: "`r Sys.Date()`"
graphics: yes
output: BiocStyle::pdf_document
vignette: >
    %\VignetteIndexEntry{dce}
    %\VignetteEngine{knitr::rmarkdown}
    %\VignetteEncoding{UTF-8}
---

# Introduction



# Installation and loading
```{r global_options, include=FALSE}
knitr::opts_chunk$set(message=FALSE, out.width="\\textwidth", fig.align="center",
                      strip.white=TRUE, warning=FALSE, tidy=TRUE,
                      #out.extra='style="display:block; margin:auto;"',
                      fig.height = 4, fig.width = 8, error=FALSE)
fig.cap0 <- "Figure caption 1."
paltmp <- palette()
paltmp[3] <- "blue"
paltmp[4] <- "brown"
palette(paltmp)
```
Install the package with the bioconductor manager package.
```{r, eval=FALSE}
if (!requireNamespace("BiocManager", quietly = TRUE)) {
    install.packages("BiocManager")
}
BiocManager::install("dce")
```
Load the package with the library function.
```{r}
# library(dce)

## can be removed once dce is installed
cur.wd <- knitr::current_input(dir=TRUE)
parts <- strsplit(cur.wd, "/")[[1]]
package.dir <- paste(parts[1:(length(parts)-2)], collapse="/")
devtools::load_all(package.dir)

library(tidyverse)
library(purrr)

library(graph)
library(pcalg)
library(assertthat)

```

# Simulations

## Parameters

First we set specific parameters to define the scope and noise levels
of the simulated data.

```{r, fig.height=6, fig.width=10, fig.cap=fig.cap0}
runs <- 10 # simulation runs
p <- 0.005 # edge prob of the dag
## uniform limits:
lB <- -1
uB <- 1
## others:
n <- 100 # number of nodes
m <- c(1000,1000) # number of samples tumor and normal
sd <- 10 # standard deviation for variable distributions
## the fraction of true pos (causal effects that are differential)
truepos <- 0.9
bsruns <- 100 # bootstrap runs
perturb <- 0 # negative fraction: remove edges for inference, positive: add edges, 0: no perturbation
cormeth <- "p"
dmeth <- "euclidean"

## mini sim for cuasal effects:

tmp <- matrix(0, runs, 6)

for (i in 1:runs) {
    
    normal <- randomDAG(n, p, lB, uB)
    tumor <- newWeights(normal, lB, uB, truepos) # resample edge weights
    
    dn <- rmvDAG_2(m[2], normal, normpars = c(0,sd))   
    dt <- rmvDAG_2(m[1], tumor, normpars = c(0,sd))

    cn <- trueCov(normal)
    ct <- trueCov(tumor)

    gm <- as(normal, "matrix")
    gm[which(gm != 0)] <- 1

    gtc <- nem::transitive.closure(gm, mat=TRUE) # transitively closed graph as matrix

    diag(gtc) <- 0

    ## ground truth:
    dcet <- (cn - ct)*gtc # gtn for differential causal effects
    dcegtn <- list(dce = dcet, graph = normal, dcefull = dcet)
    class(dcegtn) <- "dce"

    tmp[i, 1] <- sum(abs(t(as(compute_causal_effects(normal, dn), "matrix"))*gtc - cn*gtc))
    tmp[i, 3] <- sum(abs(t(as(compute_causal_effects(tumor, dt), "matrix"))*gtc - ct*gtc))
    tmp[i, 5] <- sum(abs(t(as(compute_causal_effects(normal, dn), "matrix"))*gtc- cn*gtc - t(as(compute_causal_effects(tumor, dt), "matrix"))*gtc + ct*gtc))
    
    tmp[i, 2] <- sum(abs(cor(dn)*gtc - cn*gtc))
    tmp[i, 4] <- sum(abs(cor(dt)*gtc - ct*gtc))
    tmp[i, 6] <- sum(abs(cor(dn)*gtc - cn*gtc - cor(dt)*gtc + ct*gtc))
    cat(i)
}

boxplot(tmp[,1:6])

par(mfrow=c(2,3))
plot(as.vector(t(as(compute_causal_effects(normal, dn), "matrix"))*gtc), as.vector(cn*gtc))
abline(0,1,col=2)
plot(as.vector(t(as(compute_causal_effects(tumor, dt), "matrix"))*gtc), as.vector(ct*gtc))
abline(0,1,col=2)
plot(as.vector(t(as(compute_causal_effects(normal, dn), "matrix"))*gtc)-
     as.vector(t(as(compute_causal_effects(tumor, dt), "matrix"))*gtc), as.vector(cn*gtc - ct*gtc))
abline(0,1,col=2)
plot(as.vector(cor(dn)*gtc), as.vector(cn*gtc))
abline(0,1,col=2)
plot(as.vector(cor(dt)*gtc), as.vector(ct*gtc))
abline(0,1,col=2)
plot(as.vector(cor(dn)*gtc - cor(dt)*gtc), as.vector(cn*gtc - ct*gtc))
abline(0,1,col=2)

```

## Simulation loop

We create an array to store the accuracy results for our method, the
random baseline and competing methods bla and blabla. \textcolor{red}{see github project}

After simulation we use a boxplot to compare the accuracies of the
respective methods.

```{r, fig.height=6, fig.width=10, fig.cap=fig.cap0}
acc <- array(0, c(runs,5,2),
             dimnames = list(runs = paste0("run_", seq_len(runs)),
                             methods = c("dce", "random", "full linear", "simple correlation", "test"),
                             metrics = c("correlation", "metric2")))
gtnfeat <- array(0, c(runs, 6, 2),
                 dimnames = list(runs = paste0("run_", seq_len(runs)),
                                 features = c("avg children", "avg parents",
                                              "childless", "parentless",
                                              "maxpathlength", "density"),
                                 gtn = c("originial", "transitive closure")))


for (i in 1:runs) {
    cat(i)
                                        #for (j in 1:1000) {
                                        #   set.seed(j)
    normal <- randomDAG(n, p, lB, uB)
    tumor <- newWeights(normal, lB, uB, truepos) # resample edge weights
    
    dn <- rmvDAG_2(m[2], normal, normpars = c(0,sd))   
    dt <- rmvDAG_2(m[1], tumor, normpars = c(0,sd))

    cn <- trueCov(normal)
    ct <- trueCov(tumor)

    gm <- as(normal, "matrix")
    gm[which(gm != 0)] <- 1

    gtc <- nem::transitive.closure(gm, mat=TRUE) # transitively closed graph as matrix

    ## save features of gtn, which might correlate with accuracy:
    gtr <- nem::transitive.reduction(gm)
    gtnfeat[i, 1, 1] <- mean(apply(gm, 1, sum))
    gtnfeat[i, 2, 1] <- mean(apply(gm, 2, sum))
    gtnfeat[i, 3, 1] <- sum(apply(gm, 1, sum) == 0)
    gtnfeat[i, 4, 1] <- sum(apply(gm, 2, sum) == 0)
    diag(gtr) <- 1
    for (j in seq_len(n)) {
        gtr <- gtr%*%gtr
        gtr[which(gtr > 1)] <- 1
        if (all(gtr == gtc)) { break() }
    }
    gtnfeat[i, 5, 1] <- j+1
    gtnfeat[i, 6, 1] <- sum(gm)
    
    diag(gtc) <- 0

    gtnfeat[i, 1, 2] <- mean(apply(gtc, 1, sum))
    gtnfeat[i, 2, 2] <- mean(apply(gtc, 2, sum))
    gtnfeat[i, 3, 2] <- sum(apply(gtc, 1, sum) == 0)
    gtnfeat[i, 4, 2] <- sum(apply(gtc, 2, sum) == 0)
    gtnfeat[i, 5, 2] <- j+1
    gtnfeat[i, 6, 2] <- sum(gtc)
    
    ## ground truth:
    dcet <- (cn - ct)*gtc # gtn for differential causal effects
    dcegtn <- list(dce = dcet, graph = normal, dcefull = dcet)
    class(dcegtn) <- "dce"
    
    ## perturb network:

    if (perturb < 0) {
        adjn <- as(normal, "matrix")
        remedge <- sample(which(adjn != 0), floor(sum(adjn != 0)*abs(perturb)))
        adjn[remedge] <- 0
    }
    if (perturb > 0) {
        adjn <- as(normal, "matrix")
        addedge <- sample(which(adjn == 0 & upper.tri(adjn)), floor(sum(adjn != 0)*perturb))
        adjn[addedge] <- 1
    }

    ## our inference:

    accfun <- function(a,b) {
        a <- as.vector(a)
        b <- as.vector(b)
        z <- dist(rbind(a,b), method = dmeth)
        return(z)
    }
  
    ## test method::
    dcei <- fulllin(
        normal, dn,
        tumor, dt, conf = 0
    )
    dceitest <- dcei
    
    dcei <- dcei$dce
    coridx <- which(dcet != 0 | dcei != 0)
    acc[i, 5, 1] <- cor(as.vector(dcet[coridx]), as.vector(dcei[coridx]), method = cormeth)
    acc[i, 5, 2] <- accfun(dcet[coridx], dcei[coridx])
    
    ## full linear model:
    dcei <- fulllin(
        normal, dn,
        tumor, dt
    )
    dceifl <- dcei
    
    dcei <- dcei$dce
    coridx <- which(dcet != 0 | dcei != 0)
    acc[i, 3, 1] <- cor(as.vector(dcet[coridx]), as.vector(dcei[coridx]), method = cormeth)
    acc[i, 3, 2] <- accfun(dcet[coridx], dcei[coridx])

    ## normal
    dcei <- compute_differential_causal_effects(
        normal, dn,
        tumor, dt
    )
    dcein <- dcei
    
    dcei <- dcei$dce
    coridx <- which(dcet != 0 | dcei != 0)
    acc[i, 1, 1] <- cor(as.vector(dcet[coridx]), as.vector(dcei[coridx]), method = cormeth)
    acc[i, 1, 2] <- accfun(dcet[coridx], dcei[coridx])
    
    ## simple correlation:
    dcei <- (cor(dn) - cor(dt))*gtc
    dcec <- list(dce = dcei, graph = as(gtc, "graphNEL"), dcefull = dcei)
    dceic <- dcec
    class(dceic) <- "dce"
    
    dcec <- dcec$dce
    coridx <- which(dcet != 0 | dcec != 0)
    acc[i, 4, 1] <- cor(as.vector(dcet[coridx]), as.vector(dcec[coridx]), method = cormeth)
    acc[i, 4, 2] <- accfun(dcet[coridx], dcei[coridx])

    ## random base line:
    dcei <- dcet
    dcei[which(gtc != 0)] <- runif(sum(gtc != 0), lB, uB)
    dcer <- list(dce = dcei, graph = as(gtc, "graphNEL"), dcefull = dcei)
    dceir <- dcer
    class(dceir) <- "dce"
    
    dcer <- dcer$dce
    coridx <- which(dcet != 0 | dcer != 0)
    acc[i, 2, 1] <- cor(as.vector(dcet[coridx]), as.vector(dcer[coridx]), method = cormeth)
    acc[i, 2, 2] <- accfun(dcet[coridx], dcei[coridx])

    ## ## full linear model bootstrapped:
    ## dcei <- compute_differential_causal_effects(
    ##     normal, dn,
    ##     tumor, dt,
    ##     method = "full",
    ##     bootstrap = TRUE, runs = bsruns, replace = 0, frac = 0.5
    ## )
    ## dceiflbs <- dcei
    
    ## dcei <- dcei$dce
    ## coridx <- which(dcet != 0 | dcei != 0)
    ## acc[i, 7, 1] <- cor(as.vector(dcet[coridx]), as.vector(dcei[coridx]), method = cormeth)
    ## acc[i, 7, 2] <- dist(rbind(as.vector(dcet), as.vector(dcei)))
    
    ## if (acc[i, 1, 1] > 0.9) { break() }

    ## if (acc[i, 5, 2] < acc[i, 3, 2]) { stop() }

    ## acc[i, , ]

}

show <- 1:5
par(mfrow=c(1,3))
boxplot(acc[seq_len(runs), show, 1], col = c(rgb(1,0,0), rgb(0.5,0.5,0.5), rgb(0,1,0), rgb(0,0,1)), main = dimnames(acc)[[3]][1])
boxplot(acc[seq_len(runs), show, 2], col = c(rgb(1,0,0), rgb(0.5,0.5,0.5), rgb(0,1,0), rgb(0,0,1)), main= dimnames(acc)[[3]][2])
boxplot(1-acc[seq_len(runs), show, 2]/acc[seq_len(runs), 2, 2], col = c(rgb(1,0,0), rgb(0.5,0.5,0.5), rgb(0,1,0), rgb(0,0,1)), main= dimnames(acc)[[3]][2])

```

## Show correlation of features to accuracy

```{r}

par(mfrow=c(2,6))
for (i in seq_len(2)) {
    for (j in seq_len(6)) {
        plot(gtnfeat[, j, i], acc[, 1, 1],
             xlab = dimnames(gtnfeat)[[2]][j],
             ylab = "accuracy", main = dimnames(gtnfeat)[[3]][i],
             sub = cor(gtnfeat[, j, i], acc[, 1, 1]))
    }
}

```

## Visualisation of one simulations run


```{r, fig.height=6, fig.width=10, fig.cap=fig.cap0}

par(mfrow=c(2,4))
class(dcet) <- class(dcer) <- "dce"
plot(dcegtn, dec = 2)
plot(dceir, dec = 2)
plot(dcein, dec = 2)
plot(dceifl, dec = 2)
plot(dceic, dec = 2)

par(mfrow=c(2,4))
hist(dcegtn$dce)
hist(dceir$dce)
hist(dcein$dce)
hist(dceifl$dce)
hist(dceic$dce)


```

# Session information

```{r}

sessionInfo()

```

# References:

Taruttis et al

Matthuis et al

...
