---
title: "Simulations: Differential causal effects for pathway enrichment \n
Simulations of differential causal effects between two groups."
author: "Kim Jablonski, Martin Pirkl"
date: "`r Sys.Date()`"
graphics: yes
output: BiocStyle::pdf_document
vignette: >
    %\VignetteIndexEntry{dce}
    %\VignetteEngine{knitr::rmarkdown}
    %\VignetteEncoding{UTF-8}
---

# Introduction



# Installation and loading
```{r global_options, include=FALSE}
knitr::opts_chunk$set(message=FALSE, out.width="125%", fig.align="center",
                      strip.white=TRUE, warning=FALSE, tidy=TRUE,
                      #out.extra='style="display:block; margin:auto;"',
                      fig.height = 4, fig.width = 8, error=FALSE)
fig.cap0 <- "Figure caption 1."
paltmp <- palette()
paltmp[3] <- "blue"
paltmp[4] <- "brown"
palette(paltmp)
```
Install the package with the bioconductor manager package.
```{r, eval=FALSE}
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
BiocManager::install("dce")
```
Load the package with the library function.
```{r}
library(dce)

## can be removed once dce is installed

source("CausalPathways/dce/R/utils.R")
source("CausalPathways/dce/R/main.R")

library(tidyverse)
library(purrr)

library(graph)
library(pcalg)
library(assertthat)

```

# Simulations

## Parameters

First we set specific parameters to define the scope and noise levels
of the simulated data.

```{r, fig.height=6, fig.width=10, fig.cap=fig.cap0}
runs <- 100 # simulation runs
p <- 0.2 # edge prob of the dag
## uniform limits:
lB <- -1
uB <- 1
## others:
n <- 10 # number of nodes
m <- 100 # number of samples
sd <- 0.1 # standard deviation for variable distributions
## the fraction of true pos (causal effects that are differential)
truepos <- 0.5
```

## Simulation loop

We create an array to store the accuracy results for our method, the
random baseline and competing methods bla and blabla. \textcolor{red}{see github project}

After simulation we use a boxplot to compare the accuracies of the
respective methods.

```{r, fig.height=6, fig.width=10, fig.cap=fig.cap0}
acc <- array(0, c(100,4,5),
             dimnames = list(runs = paste0("run_", seq_len(runs)),
                             methods = c("dce", "random", "method3", "method3"),
                             metrics = c("correlation", "distance", "metric3",
                                         "metric4", "metric5")))

for (i in 1:runs) {

    #for (j in 1:1000) {
     #   set.seed(j)
  normal <- randomDAG(n, p, lB, uB)
  dn <- rmvDAG_2(m, normal, normpars = c(0,sd))

  tumor <- newWeights(normal, lB, uB, truepos) # resample edge weights
  dt <- rmvDAG_2(m, tumor, normpars = c(0,sd))

  cn <- trueCov(normal)
  ct <- trueCov(tumor)

  gm <- as(normal, "matrix")
  gm[which(gm != 0)] <- 1

  gtc <- mnem:::mytc(gm) # transitively closed graph as matrix
  diag(gtc) <- 0

  ## ground truth:
  dcet <- (cn - ct)*gtc # gtn for differential causal effects
  dcetb <- dcet
  dcetb[which(abs(dcet) > 0.5)] <- 1
  dcetb[which(abs(dcet) <= 0.5)] <- 0

  ## our inference:
  dcei <- compute_differential_causal_effects(
      normal, dn,
      tumor, dt
  )
  
  dcei <- dcei*gtc
  dceib <- dcei
  dceib[which(abs(dcei) > 0.5)] <- 1
  dceib[which(abs(dcei) <= 0.5)] <- 0

  acc[i, 1, 1] <- cor(as.vector(dcet), as.vector(dcei), method = "s")
  acc[i, 1, 2] <- dist(rbind(as.vector(dcet), as.vector(dcei)))
  tp <- sum(dcetb == 1 & dceib == 1)
  fp <- sum(dcetb == 0 & dceib == 1)
  fn <- sum(dcetb == 1 & dceib == 0)
  tn <- sum(dcetb == 0 & dceib == 0)
  acc[i, 1, 3] <- tp/(tp+fn)
  acc[i, 1, 4] <- tn/(tn+fp)
  acc[i, 1, 5] <- (tp+tn)/(tn+fp+tp+fn)

  ## random base line:
  dcer <- dcet
  dcer[which(dcet != 0)] <- runif(sum(dcet != 0), lB, uB)
  dcerb <- dcer
  dcerb[which(abs(dcer) > 0.5)] <- 1
  dcerb[which(abs(dcer) <= 0.5)] <- 0

  acc[i, 2, 1] <- cor(as.vector(dcet), as.vector(dcer), method = "s")
  acc[i, 2, 2] <- dist(rbind(as.vector(dcet), as.vector(dcer)))
  tp <- sum(dcetb == 1 & dcerb == 1)
  fp <- sum(dcetb == 0 & dcerb == 1)
  fn <- sum(dcetb == 1 & dcerb == 0)
  tn <- sum(dcetb == 0 & dcerb == 0)
  acc[i, 2, 3] <- tp/(tp+fn)
  acc[i, 2, 4] <- tn/(tn+fp)
  acc[i, 2, 5] <- (tp+tn)/(tn+fp+tp+fn)

        #if (acc[i, 1, 1] > 0.9) { break() }
    #}

  ## acc[i, , ]

}

par(mfrow=c(2,3))
boxplot(acc[, 1:4, 1], col = c(rgb(1,0,0), rgb(0.5,0.5,0.5), rgb(0,1,0), rgb(0,0,1)))
boxplot(acc[, 1:4, 2], col = c(rgb(1,0,0), rgb(0.5,0.5,0.5), rgb(0,1,0), rgb(0,0,1)))
boxplot(acc[, 1:4, 3], col = c(rgb(1,0,0), rgb(0.5,0.5,0.5), rgb(0,1,0), rgb(0,0,1)))
boxplot(acc[, 1:4, 4], col = c(rgb(1,0,0), rgb(0.5,0.5,0.5), rgb(0,1,0), rgb(0,0,1)))
boxplot(acc[, 1:4, 5], col = c(rgb(1,0,0), rgb(0.5,0.5,0.5), rgb(0,1,0), rgb(0,0,1)))
```

## Visualisation of one simulations run


```{r, fig.height=6, fig.width=10, fig.cap=fig.cap0}
## set.seed(1) # awesome result
efreq <- round(dcet[which(dcet != 0)], 2)
efreqi <- round(dcei[which(dcei != 0)], 2)
efreqr <- round(dcer[which(dcer != 0)], 2)
## even though the gtn does not allow for dce > 2, noise can pass that limit (just for the colors)
efreq[abs(efreq) > 2] <- 2
efreqi[abs(efreqi) > 2] <- 2
efreqr[abs(efreqr) > 2] <- 2

par(mfrow=c(1,3))
dnf <- mnem:::adj2dnf(gtc)
dnf <- dnf[grep("=", dnf)] # this preprocessing will be implemented in plotDnf (bug)
mnem::plotDnf(dnf, labels = efreq, edgecol = rgb(abs(efreq)/2,0,(2-abs(efreq))/2))
mnem::plotDnf(dnf, labels = efreqi, edgecol = rgb(abs(efreqi)/2,0,(2-abs(efreqi))/2))
mnem::plotDnf(dnf, labels = efreqr, edgecol = rgb(abs(efreqr)/2,0,(2-abs(efreqr))/2))
```

# Session information

```{r}
sessionInfo()
```

# References:

Taruttis et al

Matthuis et al

...
