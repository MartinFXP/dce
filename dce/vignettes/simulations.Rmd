---
title: "Simulations: Differential causal effects for pathway enrichment \n
Simulations of differential causal effects between two groups."
author: "Kim Jablonski, Martin Pirkl"
date: "`r Sys.Date()`"
graphics: yes
output: BiocStyle::pdf_document
vignette: >
    %\VignetteIndexEntry{dce}
    %\VignetteEngine{knitr::rmarkdown}
    %\VignetteEncoding{UTF-8}
---

# Introduction



# Installation and loading
```{r global_options, include=FALSE}
knitr::opts_chunk$set(message=FALSE, out.width="\\textwidth", fig.align="center",
                      strip.white=TRUE, warning=FALSE, tidy=TRUE,
                      #out.extra='style="display:block; margin:auto;"',
                      fig.height = 4, fig.width = 8, error=FALSE)
fig.cap0 <- "Figure caption 1."
paltmp <- palette()
paltmp[3] <- "blue"
paltmp[4] <- "brown"
palette(paltmp)
```
Install the package with the bioconductor manager package.
```{r, eval=FALSE}
if (!requireNamespace("BiocManager", quietly = TRUE)) {
    install.packages("BiocManager")
}
BiocManager::install("dce")
```
Load the package with the library function.
```{r}
# library(dce)

## can be removed once dce is installed
cur.wd <- knitr::current_input(dir=TRUE)
parts <- strsplit(cur.wd, "/")[[1]]
package.dir <- paste(parts[1:(length(parts)-2)], collapse="/")
devtools::load_all(package.dir)

library(tidyverse)
library(purrr)

library(graph)
library(pcalg)
library(assertthat)

```

# Simulations

## Parameters

First we set specific parameters to define the scope and noise levels
of the simulated data.

```{r, fig.height=6, fig.width=10, fig.cap=fig.cap0}
runs <- 10 # simulation runs
p <- 0.2 # edge prob of the dag
## uniform limits:
lB <- -1
uB <- 1
## others:
n <- 10 # number of nodes
m <- c(1000,100) # number of samples tumor and normal
sd <- 10 # standard deviation for variable distributions
## the fraction of true pos (causal effects that are differential)
truepos <- 0.9
bsruns <- 100
```

## Simulation loop

We create an array to store the accuracy results for our method, the
random baseline and competing methods bla and blabla. \textcolor{red}{see github project}

After simulation we use a boxplot to compare the accuracies of the
respective methods.

```{r, fig.height=6, fig.width=10, fig.cap=fig.cap0}
acc <- array(0, c(runs,6,5),
             dimnames = list(runs = paste0("run_", seq_len(runs)),
                             methods = c("dce", "random", "bootstrap",
                                         "subsample", "full linear", "subsample2"),
                             metrics = c("correlation", "distance", "metric3",
                                         "metric4", "metric5")))
gtnfeat <- array(0, c(runs, 6, 2),
                 dimnames = list(runs = paste0("run_", seq_len(runs)),
                                 features = c("avg children", "avg parents",
                                              "childless", "parentless",
                                              "maxpathlength", "density"),
                                 gtn = c("originial", "transitive closure")))


for (i in 1:runs) {
    cat(i)
                                        #for (j in 1:1000) {
                                        #   set.seed(j)
    normal <- randomDAG(n, p, lB, uB)
    dn <- rmvDAG_2(m[2], normal, normpars = c(0,sd))
    
    tumor <- newWeights(normal, lB, uB, truepos) # resample edge weights
    dt <- rmvDAG_2(m[1], tumor, normpars = c(0,sd))

    cn <- trueCov(normal)
    ct <- trueCov(tumor)

    gm <- as(normal, "matrix")
    gm[which(gm != 0)] <- 1

    gtc <- mnem:::mytc(gm) # transitively closed graph as matrix

    ## save features of gtn, which might correlate with accuracy:
    gtr <- nem::transitive.reduction(gm)
    gtnfeat[i, 1, 1] <- mean(apply(gm, 1, sum))
    gtnfeat[i, 2, 1] <- mean(apply(gm, 2, sum))
    gtnfeat[i, 3, 1] <- sum(apply(gm, 1, sum) == 0)
    gtnfeat[i, 4, 1] <- sum(apply(gm, 2, sum) == 0)
    diag(gtr) <- 1
    for (j in seq_len(n)) {
        gtr <- gtr%*%gtr
        gtr[which(gtr > 1)] <- 1
        if (all(gtr == gtc)) { break() }
    }
    gtnfeat[i, 5, 1] <- j+1
    gtnfeat[i, 6, 1] <- sum(gm)
    
    diag(gtc) <- 0

    gtnfeat[i, 1, 2] <- mean(apply(gtc, 1, sum))
    gtnfeat[i, 2, 2] <- mean(apply(gtc, 2, sum))
    gtnfeat[i, 3, 2] <- sum(apply(gtc, 1, sum) == 0)
    gtnfeat[i, 4, 2] <- sum(apply(gtc, 2, sum) == 0)
    gtnfeat[i, 5, 2] <- j+1
    gtnfeat[i, 6, 2] <- sum(gtc)
    
    ## ground truth:
    dcet <- (cn - ct)*gtc # gtn for differential causal effects
    dcegtn <- list(dce = dcet, graph = normal, dcefull = dcet)
    class(dcegtn) <- "dce"
    
    dcetb <- dcet
    dcetb[which(abs(dcet) > 0.5)] <- 1
    dcetb[which(abs(dcet) <= 0.5)] <- 0

    ## our inference:
  
    ## bootstrap/subsample2:
    dcei <- compute_differential_causal_effects(
        normal, dn,
        tumor, dt,
        bootstrap = TRUE, runs = bsruns, replace = 0, frac = 0.5,
        strap = 1
    )
    dceibs2 <- dcei
    
    dceib <- dcei$dce
    dceib[which(abs(dceib) > 0.5)] <- 1
    dceib[which(abs(dceib) <= 0.5)] <- 0

    dcei <- dcei$dce
    coridx <- which(dcet != 0 | dcei != 0)
    acc[i, 6, 1] <- cor(as.vector(dcet[coridx]), as.vector(dcei[coridx]), method = "p")
    acc[i, 6, 2] <- dist(rbind(as.vector(dcet), as.vector(dcei)))
    tp <- sum(dcetb == 1 & dceib == 1)
    fp <- sum(dcetb == 0 & dceib == 1)
    fn <- sum(dcetb == 1 & dceib == 0)
    tn <- sum(dcetb == 0 & dceib == 0)
    acc[i, 6, 3] <- tp/(tp+fn)
    acc[i, 6, 4] <- tn/(tn+fp)
    acc[i, 6, 5] <- (tp+tn)/(tn+fp+tp+fn)
    
    ## bootstrap:
    dcei <- compute_differential_causal_effects(
        normal, dn,
        tumor, dt,
        bootstrap = TRUE, runs = bsruns, replace = 0, frac = 0.5
    )
    dceibs <- dcei
    
    dceib <- dcei$dce
    dceib[which(abs(dceib) > 0.5)] <- 1
    dceib[which(abs(dceib) <= 0.5)] <- 0

    dcei <- dcei$dce
    coridx <- which(dcet != 0 | dcei != 0)
    acc[i, 3, 1] <- cor(as.vector(dcet[coridx]), as.vector(dcei[coridx]), method = "p")
    acc[i, 3, 2] <- dist(rbind(as.vector(dcet), as.vector(dcei)))
    tp <- sum(dcetb == 1 & dceib == 1)
    fp <- sum(dcetb == 0 & dceib == 1)
    fn <- sum(dcetb == 1 & dceib == 0)
    tn <- sum(dcetb == 0 & dceib == 0)
    acc[i, 3, 3] <- tp/(tp+fn)
    acc[i, 3, 4] <- tn/(tn+fp)
    acc[i, 3, 5] <- (tp+tn)/(tn+fp+tp+fn)
    
    ## subsampling:
    dcei <- compute_differential_causal_effects(
        normal, dn,
        tumor, dt,
        bootstrap = TRUE, runs = bsruns, replace = 1, frac = 1
    )
    dceiss <- dcei
    
    dceib <- dcei$dce
    dceib[which(abs(dceib) > 0.5)] <- 1
    dceib[which(abs(dceib) <= 0.5)] <- 0

    dcei <- dcei$dce
    coridx <- which(dcet != 0 | dcei != 0)
    acc[i, 4, 1] <- cor(as.vector(dcet[coridx]), as.vector(dcei[coridx]), method = "p")
    acc[i, 4, 2] <- dist(rbind(as.vector(dcet), as.vector(dcei)))
    tp <- sum(dcetb == 1 & dceib == 1)
    fp <- sum(dcetb == 0 & dceib == 1)
    fn <- sum(dcetb == 1 & dceib == 0)
    tn <- sum(dcetb == 0 & dceib == 0)
    acc[i, 4, 3] <- tp/(tp+fn)
    acc[i, 4, 4] <- tn/(tn+fp)
    acc[i, 4, 5] <- (tp+tn)/(tn+fp+tp+fn)
    
    ## full linear model:
    dcei <- fulllin(
        normal, dn,
        tumor, dt
    )
    dceifl <- dcei
    
    dceib <- dcei$dce
    dceib[which(abs(dceib) > 0.5)] <- 1
    dceib[which(abs(dceib) <= 0.5)] <- 0

    dcei <- dcei$dce
    coridx <- which(dcet != 0 | dcei != 0)
    acc[i, 5, 1] <- cor(as.vector(dcet[coridx]), as.vector(dcei[coridx]), method = "p")
    acc[i, 5, 2] <- dist(rbind(as.vector(dcet), as.vector(dcei)))
    tp <- sum(dcetb == 1 & dceib == 1)
    fp <- sum(dcetb == 0 & dceib == 1)
    fn <- sum(dcetb == 1 & dceib == 0)
    tn <- sum(dcetb == 0 & dceib == 0)
    acc[i, 5, 3] <- tp/(tp+fn)
    acc[i, 5, 4] <- tn/(tn+fp)
    acc[i, 5, 5] <- (tp+tn)/(tn+fp+tp+fn)
    
    ## normal
    dcei <- compute_differential_causal_effects(
        normal, dn,
        tumor, dt
    )
    dcein <- dcei
    
    dceib <- dcei$dce
    dceib[which(abs(dceib) > 0.5)] <- 1
    dceib[which(abs(dceib) <= 0.5)] <- 0

    dcei <- dcei$dce
    coridx <- which(dcet != 0 | dcei != 0)
    acc[i, 1, 1] <- cor(as.vector(dcet[coridx]), as.vector(dcei[coridx]), method = "p")
    acc[i, 1, 2] <- dist(rbind(as.vector(dcet), as.vector(dcei)))
    tp <- sum(dcetb == 1 & dceib == 1)
    fp <- sum(dcetb == 0 & dceib == 1)
    fn <- sum(dcetb == 1 & dceib == 0)
    tn <- sum(dcetb == 0 & dceib == 0)
    acc[i, 1, 3] <- tp/(tp+fn)
    acc[i, 1, 4] <- tn/(tn+fp)
    acc[i, 1, 5] <- (tp+tn)/(tn+fp+tp+fn)
    
    ## random base line:
    dcei <- dcet
    dcei[which(gtc != 0)] <- runif(sum(gtc != 0), lB, uB)
    dcer <- list(dce = dcei, graph = as(gtc, "graphNEL"), dcefull = dcei)
    dceir <- dcer
    class(dceir) <- "dce"
    
    dcerb <- dcer$dce
    dcerb[which(abs(dcerb) > 0.5)] <- 1
    dcerb[which(abs(dcerb) <= 0.5)] <- 0

    dcer <- dcer$dce
    coridx <- which(dcet != 0 | dcer != 0)
    acc[i, 2, 1] <- cor(as.vector(dcet[coridx]), as.vector(dcer[coridx]), method = "p")
    acc[i, 2, 2] <- dist(rbind(as.vector(dcet), as.vector(dcer)))
    tp <- sum(dcetb == 1 & dcerb == 1)
    fp <- sum(dcetb == 0 & dcerb == 1)
    fn <- sum(dcetb == 1 & dcerb == 0)
    tn <- sum(dcetb == 0 & dcerb == 0)
    acc[i, 2, 3] <- tp/(tp+fn)
    acc[i, 2, 4] <- tn/(tn+fp)
    acc[i, 2, 5] <- (tp+tn)/(tn+fp+tp+fn)

                                        #if (acc[i, 1, 1] > 0.9) { break() }
                                        #}

    ## acc[i, , ]

}

par(mfrow=c(2,3))
boxplot(acc[seq_len(runs), 1:6, 1], col = c(rgb(1,0,0), rgb(0.5,0.5,0.5), rgb(0,1,0), rgb(0,0,1)), main="Correlation")
boxplot(acc[seq_len(runs), 1:6, 2], col = c(rgb(1,0,0), rgb(0.5,0.5,0.5), rgb(0,1,0), rgb(0,0,1)), main="Distance")
boxplot(acc[seq_len(runs), 1:6, 3], col = c(rgb(1,0,0), rgb(0.5,0.5,0.5), rgb(0,1,0), rgb(0,0,1)), main="Sensitivity")
boxplot(acc[seq_len(runs), 1:6, 4], col = c(rgb(1,0,0), rgb(0.5,0.5,0.5), rgb(0,1,0), rgb(0,0,1)), main="Specificity")
boxplot(acc[seq_len(runs), 1:6, 5], col = c(rgb(1,0,0), rgb(0.5,0.5,0.5), rgb(0,1,0), rgb(0,0,1)), main="Accuracy")

```

## Show correlation of features to accuracy

```{r}

par(mfrow=c(2,6))
for (i in seq_len(2)) {
    for (j in seq_len(6)) {
        plot(gtnfeat[, j, i], acc[, 1, 1],
             xlab = dimnames(gtnfeat)[[2]][j],
             ylab = "accuracy", main = dimnames(gtnfeat)[[3]][i],
             sub = cor(gtnfeat[, j, i], acc[, 1, 1]))
    }
}

```

## Visualisation of one simulations run


```{r, fig.height=6, fig.width=10, fig.cap=fig.cap0}

par(mfrow=c(3,3))
class(dcet) <- class(dcer) <- "dce"
plot(dcegtn)
plot(dceir)
plot(dcein)
plot(dceibs)
plot(dceib2)
plot(dceiss)
plot(dceifl)

```

# Session information

```{r}
sessionInfo()





 mat1 <- as(g1, "matrix")
    mat2 <- as(g2, "matrix")
    mat1[which(mat1 != 0)] <- 1
    mat2[which(mat2 != 0)] <- 1
    dagtc <- mnem:::mytc(mat1)
    df <- rbind(d1, d2)
    colnames(df) <- paste0("X", seq_len(ncol(df)))
    df <- as.data.frame(cbind(df,
                              N = c(rep(1, nrow(d1)),
                                    rep(0, nrow(d2))),
                              T = c(rep(0, nrow(d1)),
                                    rep(1, nrow(d2)))))
    dce <- mat1*0
    for (i in seq_len(n)) {
        for (j in seq_len(n)) {
            if (dagtc[i, j] == 1 & i != j) {
                Z <- pcalg::backdoor(mat1, i, j, type = "dag")
                Z <- colnames(df)[Z]
                X <- colnames(df)[i]
                Y <- colnames(df)[j]
                if (length(Z) > 0) {
                    Lfit <- lm(paste0(Y, " ~ ",
                                      X, "*N - ",
                                      X, "*T + ",
                                      Z, "*N - ",
                                      Z, "*T"
                                      ),
                               df)
                } else {
                    Lfit <- lm(paste0(Y, " ~ ",
                                      X, "*N - ",
                                      X, "*T"
                                      ),
                               df)
                }
                dce[i, j] <- Lfit$coefficients[3]
            }
        }
    }

```

# References:

Taruttis et al

Matthuis et al

...
